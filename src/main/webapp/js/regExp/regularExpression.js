//替换一切
function regAll(regAll){
	var regAll = /^[a-zA-Z0-9]{1,}[\:]{0,}[\/]{0,}[[a-zA-Z0-9]{0,}[\.]{0,}]{0,} | \d{1,}|[a-zA-Z]{1,}$/;
	var regExpTel = new RegExp(regAll);
	return regExpTel.test(regAll);
}

//校验登录名：只能输入5-20个以字母开头、可带数字、“_”、“.”的字串
//^[a-zA-Z]{1} 表示第一个字符要求是字母。
//([a-zA-Z0-9]|[._]){4,19} 表示从第二位开始（因为它紧跟在上个表达式后面）的一个长度为4到9位的字符串，
//它要求是由大小写字母、数字或者特殊字符集[._]组成。
function regLog(login){
	var regLog = /^[a-zA-Z]{1}([a-zA-Z0-9]|[._]){4,19}$/;
	var reg = new RegExp(regLog);
	return reg.test(login);
}

//校验普通电话、传真号码：可以“+”或数字开头，可含有“-” 和 “ ”
function regTel(telphone){
	var regTel = /^[+]{0,1}(\d){1,3}[ ]?([-]?((\d)|[ ]){1,12})+$/;
	var reg = new RegExp(regTel);
	return reg.test(telphone);
}


//校验纯中文字符
function regChina(china){
	var regChina = /^[\u4E00-\u9FA5]+$/;
	var reg = new RegExp(regChina);
	return reg.test(china);
}


//正浮点数 
function regDou(dou){
	var regDou = /^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$/;
	var reg = new RegExp(regDou);
	return reg.test(dou);
}

//正整数和小数
function regNum(num){
	var regNum = /^\d{1,}|\d{1,}\.\d{1,5}$/;
	var reg = new RegExp(regNum);
	return reg.test(num);
}

//邮箱	
//zhangshna.Mr@163.com	
//abc_Wang.dd@sian.com	
//abc_Wang.dd.cc@sian.com
function regEmail(email){
	var regEmail = /^(\w+)(\.\w+)*@(\w)+((\.\w+)+)$/;
	var reg = new RegExp(regEmail);
	return reg.test(email);
}


//身份证号
// 身份证号码为15位或者18位，15位时全为数字，18位前17位为数字，最后一位是校验位，可能为数字或字符X
function regIdCard(idCard) {
	var regIdCard = /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/;
	var num1 = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
	var num2 = idCard.split("", idCard.length);
	var count = 0;
	var reg = new RegExp(regIdCard);
	if (reg.test(idCard)) {
		for (var i = 0; i < num1.length; i++) {
			count += num1[i] * num2[i];
		}
//0，1，2，3，4，5，6，7，8，9，10 的数字校验位分别为：
//1，0，X，9，8，7，6，5，4，3，2
		var last = num2[num2.length-1];	//获取身份证的最后一位
		var a = count % 11;
		if(a == 0){
			return last == 1;
		}else if (a == 1) {
			return last == 0;
		}else if (a == 2) {
			return last == 'X';
		}else if (a == 3) {
			return last == 9;
		}else if (a == 4) {
			return last == 8;
		}else if (a == 5) {
			return last == 7;
		}else if (a == 6) {
			return last == 6;
		}else if (a == 7) {
			return last == 5;
		}else if (a == 8) {
			return last == 4;
		}else if (a == 9) {
			return last == 3;
		}else if (a == 10) {
			return last == 2;
		}
	} else {
		return false;
	}
}

//密码--数字字母组合
function regPwd(pwd){
	var regPwd = /^([0-9a-zA-Z]){6,32}$/;
	var reg = new RegExp(regPwd);
	return reg.test(pwd);
}
//秘法组合(二)
function regPwd0(pwd){
	var regPwd0 = /^([0-9a-zA-Z\.\!\$\^\*\+\=\|\.\?\\\/\(\)\{\}\[\]\~\`\#\%\,\<\>\&\:\;\'\"@]){6,32}$/;
	var reg = new RegExp(regPwd0);
	return reg.test(pwd);
}

//验证码
function regPwd0(yanzhengma){
	var regYZ = /^(\w){4}|(\w){6}$/;
	var reg = new RegExp(regYZ);
	return reg.test(yanzhengma);
}
//银行卡	16位或19位
function regBankCard(cardID){
	var regBankCard = /^(\d{16})|(\d{19})$/;
	var reg = new RegExp(regBankCard);
	return reg.test(cardID);
}

//手机电话
//中国电信手机号码开头数字 133、1349、153、180、181、189
//中国联通手机号码开头数字 130、131、132、145、155、156、185、186
//中国移动手机号码开头数字 1340-1348、135、136、137、138、139、147、150、151、152、157、158、159、182、183、184、187、188　
//腾讯大上网卡开头数字   176
function regMobile(mobile){
	var regMobile = /^((13[\d])|(15[\d])|(18[0,5-9])|(14[5,7]))\d{8}$/; 
	var reg = new RegExp(regMobile);
	return reg.test(mobile);
}

//RegExp 对象  test方法返回true或false
//var regExpTel = new RegExp(regIdCard);
//regExpTel.test("13581978748")





/**
 *正则表达式的重复类
 * {n}	匹配前一项n次
 * {n,}	匹配前一项至少n次，至多不限
 * {n,m}匹配前一项至少n次，至多m次
 *  ？	匹配前一项0次或1次，相当于{0,1}
 *  +	匹配前一项至少1次，相当于{1,}
 *  *	匹配前一项0次或多次，相当于{0,}
 * 
 * 选择符 |
 * 定位符
 * ^	匹配字符串的开头，如果在多行文本中搜索，则匹配第一行的开头
 * $	匹配字符串的结尾，如果实在多行文本中搜索，则匹配一行 的结尾
 * \b	匹配一个词的边界，也就是单词与空格间的位置。在英文中使用的比较多
 * \B	与\b相反，匹配一个非单词的边界
 * (?=p)正前向声明，要求接下来的字符与模式p匹配，但不包括匹配中的那些字符
 * (?!p)反向前声明，要求接下来的字符都不与模式p匹配
 * 
 * 标志
 * i	匹配时不区分大小写
 * g	匹配时执行全局匹配模式，即找出所有的匹配，而不是再找第一个匹配之后就停止匹配
 * m	匹配时执行多行匹配模式，及使用^匹配一行的开头和字符串的开头，使用$匹配一行的结尾或字符串的结尾
 * 
 * String对象中的正则表达式
 * match():搜索字符串，返回匹配的子字符串所组成的数组
 * replace(): 查找并替换字符串中的子字符
 * search(): 搜索子字符串，返回匹配的子字符串中的位置
 * split(): 将字符串分割成数组
 * 
 * 正则表达式对象
 * var regExpTel = new RegExp(pattern,attribute);
 * pattern : 即要匹配的正则表达式，(不需要使用"/")
 * attribute:  正则表达式的标志，也就是 i , g 或 m 
 * 方法：
 * exec(): 执行正则表达式的匹配，该方法返回一个数组，如果匹配不成功，返回null
 * test(): 测试正则表达式的匹配，该方法返回一个bool值，如果字符串中包含与正则表达式相配的文本，则返回true，否则返回false
 * toSource(): 返回RegExp对象的源代码，该方法不是所有浏览器支持的方法。
 * toString(): 将RegExp对象转换成字符串
 * 属性：
 * global: 用于表示正则表达式是否有g标志，该属性返回值为bool值
 */

// 身份证号码的匹配
//大陆的居民身份证号码有两种：18位和15位，15位的身份证号码是老一代身份证号码。
//
//18 位和15位的区别在于两个部分：第一，18位号码的年份以4位计而15位号码的年份为2位，如1987年在18位号码中为‘1987’而在15位号码中为 ‘87’，这里1987只是作为一个例子可能1987年及以后根本不存在15位号码；第二处不同在于18位号码的最后一位为数字校验码，15位号码没有数 字校验位。
//
//好吧，可能你还不知道身份证号码各个部分代表着什么，那么让我简略地介绍一下。
//
//身份证号码总共有4个部分（15位号码只有3部分），从左向右分别为：第一部分有6位，为居民在办理身份证时户口所在地的地址码（什么是地址码？自己到统计局去找吧，地址如下：http://www.stats.gov.cn/tjbz/index.htm）； 第二部分有8位（15位号码为6位），为居民出生日期码；第三部分有3位，为数字顺序码，也就是同一天出生的人的一个排序，奇数代表男性而偶数代表女性； 第四部分也就是最后一部分有1位，为数字校验码，此部分只有18位号码才有，关于数字校验码怎样计算得出，稍后会详述。
//
//先 举个例子吧，假设存在以下身份证号码：35052519870101888X（15位的话为350525870101888），用‘-’号将各部分区分如 下：350525-19870101-888-X。其中，350525为地址码，没错，到统计局查询的结果是‘福建省永春县’——一个桃园胜境，算了，不 废话；19870101为出生日期码，呵呵，1987年1月1日这一天出生的人肯定是有滴；888为顺序码，估计1987年1月1日第888个出生的人应 该没有吧，倘若真的有，那真不是人，是神！！呵呵，估计我党也不会给神这个号码，不多说了，再多说可能要人神共怒了……好吧，那么X是什么呢？怎么有些人 的身份证号码最后一位会突然冒出一个X呢，是这些人比较特殊吗？答案是：不是的，也算是吧，倘若有一种个位数等于10，这些人也不用在身份证号码的最后一 位被不明不白地加上一个X了，究竟是怎么一回事且听我细细道来^_^
//
//18位居民身份证号码最后一位——数字校验码的计算方法：
//1. 将身份证号码的前17位数分别乘以以下系数：7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2；
//2. 将以上分别相乘得到的结果相加；
//3. 将以上相加的结果除以11，得出余数；
//4. 以上得出的余数可能为0 - 10这11个数中的某一个数字。10是一个另类，因为我们的数字校验位只有1位显然需要一种替换方案，用1位将10换下，于是X派上用场了。注意了，数字校验位并不就是余数！！所得的11个余数：
//0，1，2，3，4，5，6，7，8，9，10 的数字校验位分别为：
//1，0，X，9，8，7，6，5，4，3，2
//
//PS： 通过以上的计算，现在应该非常清楚了，身份证号码的最后一位为X是因为在作校验时所得的余数是2，显然这些号码也没什么特别的吗。需要强调一下的是，X并 不是英文字母哦，而是罗马数字X，记住，它不是字母而是数字，但是，呵呵，我们一般用英文大写字母X来表示罗马数字X，囧nz……
//
//让我花点时间来校验以上的身份证号码：35052519870101888X是否正确吧，先声明倘若证实可用千万别拿去做假证，一切本人概不负责！
//
//1.前17位分别乘以相应系数：3*7+5*9+0*10+5*5+2*8+5*4+1*2+9*1+8*6+7*3+0*7+1*9+0*10+1*5+8*8+8*4+8*2=333(假如没算错的话^_^)
//2.将以上所得结果333除以11，得出余数：3
//3.呵呵35052519870101888X这个号码不是有效的身份证号码，有效号码应该为350525198701018889
//
//好了，知道了居民身份证号码各部分的意思后，我们终于可以动手寻求号码验证的解决方案了。
//
//假设我们的系统并不知道输入号码之人的任何信息（如果系统还要求输入籍贯和出生日期，还可以进一步进行检验真伪喔^_^）
//
//首 先，地址码的前2位是省级的编号，到统计局去查询得知第1位非0，并且目前的范围为1-9，9是国外的身份证号码。
//第2位的范围为0-7。统计局一般每一 年都会公布一次更新的地址码，但对比多年来的地址码可以看出地址码基本上是不变的（要是变了，现有的身份证号码岂不是都没用了^_^）。我们的地址码的正 则表达式可以这样写：/^[1-9][0-7]\d{4}/，其实，这么写不够精确，倘若要就目前的地址码写出精确的表达式，应该这么写 /^((1[1-5])|(2[1-3])|(3[1-7])|(4[1-6])|(5[0-4])|(6[1-5])|71| (8[12])|91)\d{4}/，这样写显然精确多了，但表达式长了很多，当然为求精确表达式长一点是可以接受的，但是假如统计局修改了省级地址码， 那么该表达式要根据实际情况稍作改动，所幸省级地址码应该是不会变的，呵呵，所以选择哪一种表达式都是可以的，我这就不写那么长的表达式了，所以选择 /^[1-9][0-7]\d{4}/吧。
//
//接下来就是日期了喔，呵呵，貌似之前写过的日期匹配可以借鉴来用一下，当时的那个表达式如下：
///^((((19|20)\d{2})-(0?[13-9]|1[012])-(0?[1-9]|[12]\d|30))|(((19|20)\d{2})-(0?[13578]|1[02])-31)|(((19|20)\d{2})-0?2-(0?[1-9]|1\d|2[0-8]))|((((19|20)([13579][26]|[2468][048]|0[48]))|(2000))-0?2-29))$/
//这个表达式可以匹配1900-2099年的日期，还支持闰年。
// 
//
//我 们的表达式不需要匹配那么长的时间，能够匹配二十世纪的就够了，什么，不知道二十世纪？1900-1999总该知道吧^_^为什么匹配了这个范围就够了 呢？去查一下居民身份证的历史吧，我敢打保票1900-1999的范围还太大了。至于二十一世纪的新一代，呵呵，就算他是2000年出生的，目前也就15 岁（有些算法是14岁，囧），这些人的号码应该还打印在户口簿里，拿出手也不会产生什么作用，再说，二十一世纪的人也不屑于我目前所写的匹配^_^
//
//好吧，废话太多了，开始匹配日期吧。稍微修改了以上表达式：
///((19\d{2}(0[13-9]|1[012])(0[1-9]|[12]\d|30))|(19\d{2}(0[13578]|1[02])31)|(19\d{2}02(0[1-9]|1\d|2[0-8]))|(19([13579][26]|[2468][048]|0[48])0229))/
// 
//
//正则表达式里没有计算验证的能力，所以对于顺序码，我们除了基本的匹配外无力于做什么，所以顺序码的表达式为：/\d{3}/
//
//最后一位数字验证码——/(\d|X|x)?$/。之所以那么写是因为，最后一位可能值为数字或X，但有些人可能习惯将X写成小写的x，我们必须视为正确，而最后的?是为了与15位号码兼容，此时只需将15位号码的年份用4位表示即可用我们以下整合的表达式进行匹配了——
///^[1-9][0-7]\d{4}((19\d{2}(0[13-9]|1[012])(0[1-9]|[12]\d|30))|(19\d{2}(0[13578]|1[02])31)|(19\d{2}02(0[1-9]|1\d|2[0-8]))|(19([13579][26]|[2468][048]|0[48])0229))\d{3}(\d|X|x)?$/
//地址码精确一点的表达式：
///^((1[1-5])|(2[1-3])|(3[1-7])|(4[1-6])|(5[0-4])|(6[1-5])|71|(8[12])|91)\d{4}((19\d{2}(0[13-9]|1[012])(0[1-9]|[12]\d|30))|(19\d{2}(0[13578]|1[02])31)|(19\d{2}02(0[1-9]|1\d|2[0-8]))|(19([13579][26]|[2468][048]|0[48])0229))\d{3}(\d|X|x)?$/
// 
//区号+座机号码+分机号码：regexp="^(0[0-9]{2,3}/-)?([2-9][0-9]{6,7})+(/-[0-9]{1,4})?$"
//
//手机(中国移动手机号码)：regexp="^((/(/d{3}/))|(/d{3}/-))?13[456789]/d{8}|15[89]/d{8}"
//
//所有手机号码：regexp="^((/(/d{3}/))|(/d{3}/-))?13[0-9]/d{8}|15[89]/d{8}"(新添加了158,159两个号段)
//
//((/d{11})|^((/d{7,8})|(/d{4}|/d{3})-(/d{7,8})|(/d{4}|/d{3})-(/d{7,8})-(/d{4}|/d{3}|/d{2}|/d{1})|(/d{7,8})-(/d{4}|/d{3}|/d{2}|/d{1}))$)
//
//匹配格式：
//11位手机号码
//3-4位区号，7-8位直播号码，1－4位分机号
//如：12345678901、1234-12345678-1234
// 
//1.用正则表达式限制只能输入全角字符： onkeyup="value=value.replace(/[^/uFF00-/uFFFF]/g,'')" onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[^/uFF00-/uFFFF]/g,''))"
//
//2. 用正则表达式限制只能输入数字：onkeyup="value=value.replace(/[^/d]/g,'') "onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[^/d]/g,''))"
//
//3. 用正则表达式限制只能输入数字和英文：onkeyup="value=value.replace(/[/W]/g,'') "onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[^/d]/g,''))"
//
//4.计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
//
//String.prototype.len=function(){return this.replace([^/x00-/xff]/g,"aa").length;}
//
//5.javascript中没有像vbscript那样的trim函数，我们就可以利用这个表达式来实现，如下：
//
//String.prototype.trim = function()
//{
//return this.replace(/(^/s*)|(/s*$)/g, "");
//}
//
//利用正则表达式分解和转换IP地址：
//
//6.下面是利用正则表达式匹配IP地址，并将IP地址转换成对应数值的Javascript程序：
//
//function IP2V(ip)
//{
//re=/(/d+)/.(/d+)/.(/d+)/.(/d+)/g //匹配IP地址的正则表达式
//if(re.test(ip))
//{
//return RegExp.$1*Math.pow(255,3))+RegExp.$2*Math.pow(255,2))+RegExp.$3*255+RegExp.$4*1
//}
//else
//{
//throw new Error("不是一个正确的IP地址!")
//}
//}
//
//不过上面的程序如果不用正则表达式，而直接用split函数来分解可能更简单，程序如下：
//
//var ip="10.100.20.168"
//ip=ip.split(".")
//alert("IP值是："+(ip[0]*255*255*255+ip[1]*255*255+ip[2]*255+ip[3]*1))
//正则表达式用于字符串处理、表单验证等场合，实用高效。现将一些常用的表达式收集于此，以备不时之需。
//
//
//匹配中文字符的正则表达式： [/u4e00-/u9fa5]
//评注：匹配中文还真是个头疼的事，有了这个表达式就好办了
//
//匹配双字节字符(包括汉字在内)：[^/x00-/xff]
//评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
//
//匹配空白行的正则表达式：/n/s*/r
//评注：可以用来删除空白行
//
//匹配HTML标记的正则表达式：<(/S*?)[^>]*>.*?<//1>|<.*? />
//评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力
//
//匹配首尾空白字符的正则表达式：^/s*|/s*$
//评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式
//
//匹配Email地址的正则表达式：/w+([-+.]/w+)*@/w+([-.]/w+)*/./w+([-.]/w+)*
//评注：表单验证时很实用
//
//匹配网址URL的正则表达式：[a-zA-z]+://[^/s]*
//评注：网上流传的版本功能很有限，上面这个基本可以满足需求
//
//匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
//评注：表单验证时很实用
//
//匹配国内电话号码：/d{3}-/d{8}|/d{4}-/d{7}
//评注：匹配形式如 0511-4405222 或 021-87888822
//
//匹配腾讯QQ号：[1-9][0-9]{4,}
//评注：腾讯QQ号从10000开始
//
//匹配中国邮政编码：[1-9]/d{5}(?!/d)
//评注：中国邮政编码为6位数字
//
//匹配身份证：/d{15}|/d{18}
//评注：中国的身份证为15位或18位
//
//匹配ip地址：/d+/./d+/./d+/./d+
//评注：提取ip地址时有用
//
//匹配特定数字：
//^[1-9]/d*$ //匹配正整数
//^-[1-9]/d*$ //匹配负整数
//^-?[1-9]/d*$ //匹配整数
//^[1-9]/d*|0$ //匹配非负整数（正整数 + 0）
//^-[1-9]/d*|0$ //匹配非正整数（负整数 + 0）
//^[1-9]/d*/./d*|0/./d*[1-9]/d*$ //匹配正浮点数
//^-([1-9]/d*/./d*|0/./d*[1-9]/d*)$ //匹配负浮点数
//^-?([1-9]/d*/./d*|0/./d*[1-9]/d*|0?/.0+|0)$ //匹配浮点数
//^[1-9]/d*/./d*|0/./d*[1-9]/d*|0?/.0+|0$ //匹配非负浮点数（正浮点数 + 0）
//^(-([1-9]/d*/./d*|0/./d*[1-9]/d*))|0?/.0+|0$ //匹配非正浮点数（负浮点数 + 0）
//评注：处理大量数据时有用，具体应用时注意修正
//
//匹配特定字符串：
//^[A-Za-z]+$ //匹配由26个英文字母组成的字符串
//^[A-Z]+$ //匹配由26个英文字母的大写组成的字符串
//^[a-z]+$ //匹配由26个英文字母的小写组成的字符串
//^[A-Za-z0-9]+$ //匹配由数字和26个英文字母组成的字符串
//^/w+$ //匹配由数字、26个英文字母或者下划线组成的字符串
//评注：最基本也是最常用的一些表达式
//
//匹配中文字符的正则表达式： [/u4e00-/u9fa5]
//
//匹配双字节字符(包括汉字在内)：[^/x00-/xff]
//
//匹配空行的正则表达式：/n[/s| ]*/r
//
//匹配HTML标记的正则表达式：/<(.*)>.*<///1>|<(.*) //>/
//
//匹配首尾空格的正则表达式：(^/s*)|(/s*$)
//
//匹配Email地址的正则表达式：/w+([-+.]/w+)*@/w+([-.]/w+)*/./w+([-.]/w+)*
//
//匹配网址URL的正则表达式：http://([/w-]+/.)+[/w-]+(/[/w- ./?%&=]*)?
//
//
//^/d+$ //匹配非负整数（正整数 + 0）
//^[0-9]*[1-9][0-9]*$ //匹配正整数
//^((-/d+)|(0+))$ //匹配非正整数（负整数 + 0）
//^-[0-9]*[1-9][0-9]*$ //匹配负整数
//^-?/d+$ //匹配整数
//^/d+(/./d+)?$ //匹配非负浮点数（正浮点数 + 0）
//^(([0-9]+/.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*/.[0-9]+)|([0-9]*[1-9][0-9]*))$ //匹配正浮点数
//^((-/d+(/./d+)?)|(0+(/.0+)?))$ //匹配非正浮点数（负浮点数 + 0）
//^(-(([0-9]+/.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*/.[0-9]+)|([0-9]*[1-9][0-9]*)))$ //匹配负浮点数
//^(-?/d+)(/./d+)?$ //匹配浮点数
//^[A-Za-z]+$ //匹配由26个英文字母组成的字符串
//^[A-Z]+$ //匹配由26个英文字母的大写组成的字符串
//^[a-z]+$ //匹配由26个英文字母的小写组成的字符串
//^[A-Za-z0-9]+$ //匹配由数字和26个英文字母组成的字符串
//^/w+$ //匹配由数字、26个英文字母或者下划线组成的字符串
//^[/w-]+(/.[/w-]+)*@[/w-]+(/.[/w-]+)+$
//
// 
//
//"^/d+$" //非负整数（正整数 + 0）
//"^[0-9]*[1-9][0-9]*$" //正整数
//"^((-/d+)|(0+))$" //非正整数（负整数 + 0）
//"^-[0-9]*[1-9][0-9]*$" //负整数
//"^-?/d+$" //整数
//"^/d+(/./d+)?$" //非负浮点数（正浮点数 + 0）
//"^(([0-9]+/.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*/.[0-9]+)|([0-9]*[1-9][0-9]*))$" //正浮点数
//"^((-/d+(/./d+)?)|(0+(/.0+)?))$" //非正浮点数（负浮点数 + 0）
//"^(-(([0-9]+/.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*/.[0-9]+)|([0-9]*[1-9][0-9]*)))$" //负浮点
//数
//"^(-?/d+)(/./d+)?$" //浮点数
//"^[A-Za-z]+$" //由26个英文字母组成的字符串
//"^[A-Z]+$" //由26个英文字母的大写组成的字符串
//"^[a-z]+$" //由26个英文字母的小写组成的字符串
//"^[A-Za-z0-9]+$" //由数字和26个英文字母组成的字符串
//"^/w+$" //由数字、26个英文字母或者下划线组成的字符串
//"^[/w-]+(/.[/w-]+)*@[/w-]+(/.[/w-]+)+$" //email地址
//"^[a-zA-z]+://(/w+(-/w+)*)(/.(/w+(-/w+)*))*(/?/S*)?$" //url
///^13/d{9}$/gi手机号正则表达式
//public static bool IsValidMobileNo(string MobileNo)
//{
// const string regPattern = @"^(130|131|132|133|134|135|136|137|138|139)/d{8}$";
// return Regex.IsMatch(MobileNo, regPattern);
//}
//正则表达式--验证手机号码:13[0-9]{9}
//实现手机号前带86或是+86的情况:^((/+86)|(86))?(13)/d{9}$
//电话号码与手机号码同时验证:(^(/d{3,4}-)?/d{7,8})$|(13[0-9]{9})
//提取信息中的网络链接:(h|H)(r|R)(e|E)(f|F) *= *('|")?(/w|//|//|/.)+('|"| *|>)?  
//提取信息中的邮件地址:/w+([-+.]/w+)*@/w+([-.]/w+)*/./w+([-.]/w+)*  
//提取信息中的图片链接:(s|S)(r|R)(c|C) *= *('|")?(/w|//|//|/.)+('|"| *|>)?
//提取信息中的IP地址:(/d+)/.(/d+)/.(/d+)/.(/d+)    
//提取信息中的中国手机号码:(86)*0*13/d{9}    
//提取信息中的中国固定电话号码:(/(/d{3,4}/)|/d{3,4}-|/s)?/d{8}    
//提取信息中的中国电话号码（包括移动和固定电话）:(/(/d{3,4}/)|/d{3,4}-|/s)?/d{7,14}    
//提取信息中的中国邮政编码:[1-9]{1}(/d+){5}    
//提取信息中的中国身份证号码:/d{18}|/d{15}    
//提取信息中的整数：/d+    
//提取信息中的浮点数（即小数）：(-?/d*)/.?/d+    
//提取信息中的任何数字 ：(-?/d*)(/./d+)?  
//提取信息中的中文字符串：[/u4e00-/u9fa5]*    
//提取信息中的双字节字符串 (汉字)：[^/x00-/xff]*